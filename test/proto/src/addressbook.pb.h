// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: addressbook.proto

#ifndef PROTOBUF_addressbook_2eproto__INCLUDED
#define PROTOBUF_addressbook_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_addressbook_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsConfigImpl();
void InitDefaultsConfig();
void InitDefaultsdriving_configImpl();
void InitDefaultsdriving_config();
void InitDefaultsparking_configImpl();
void InitDefaultsparking_config();
void InitDefaultstfl_blink_suppress_strategyImpl();
void InitDefaultstfl_blink_suppress_strategy();
void InitDefaultsintersection_recognition_strategyImpl();
void InitDefaultsintersection_recognition_strategy();
void InitDefaultsdrive_into_conditionImpl();
void InitDefaultsdrive_into_condition();
void InitDefaultsdrive_out_conditionImpl();
void InitDefaultsdrive_out_condition();
void InitDefaultssignal_light_status_strategyImpl();
void InitDefaultssignal_light_status_strategy();
void InitDefaultscache_pool_dynamic_strategyImpl();
void InitDefaultscache_pool_dynamic_strategy();
void InitDefaultscache_pool_static_strategyImpl();
void InitDefaultscache_pool_static_strategy();
void InitDefaultsdynamic_pose_filter_strategyImpl();
void InitDefaultsdynamic_pose_filter_strategy();
void InitDefaultslane_line_omit_frame_strategyImpl();
void InitDefaultslane_line_omit_frame_strategy();
void InitDefaultslow_speed_caseImpl();
void InitDefaultslow_speed_case();
void InitDefaultsstatic_caseImpl();
void InitDefaultsstatic_case();
inline void InitDefaults() {
  InitDefaultsConfig();
  InitDefaultsdriving_config();
  InitDefaultsparking_config();
  InitDefaultstfl_blink_suppress_strategy();
  InitDefaultsintersection_recognition_strategy();
  InitDefaultsdrive_into_condition();
  InitDefaultsdrive_out_condition();
  InitDefaultssignal_light_status_strategy();
  InitDefaultscache_pool_dynamic_strategy();
  InitDefaultscache_pool_static_strategy();
  InitDefaultsdynamic_pose_filter_strategy();
  InitDefaultslane_line_omit_frame_strategy();
  InitDefaultslow_speed_case();
  InitDefaultsstatic_case();
}
}  // namespace protobuf_addressbook_2eproto
namespace xpilot {
namespace sr2_0 {
namespace proto {
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class cache_pool_dynamic_strategy;
class cache_pool_dynamic_strategyDefaultTypeInternal;
extern cache_pool_dynamic_strategyDefaultTypeInternal _cache_pool_dynamic_strategy_default_instance_;
class cache_pool_static_strategy;
class cache_pool_static_strategyDefaultTypeInternal;
extern cache_pool_static_strategyDefaultTypeInternal _cache_pool_static_strategy_default_instance_;
class drive_into_condition;
class drive_into_conditionDefaultTypeInternal;
extern drive_into_conditionDefaultTypeInternal _drive_into_condition_default_instance_;
class drive_out_condition;
class drive_out_conditionDefaultTypeInternal;
extern drive_out_conditionDefaultTypeInternal _drive_out_condition_default_instance_;
class driving_config;
class driving_configDefaultTypeInternal;
extern driving_configDefaultTypeInternal _driving_config_default_instance_;
class dynamic_pose_filter_strategy;
class dynamic_pose_filter_strategyDefaultTypeInternal;
extern dynamic_pose_filter_strategyDefaultTypeInternal _dynamic_pose_filter_strategy_default_instance_;
class intersection_recognition_strategy;
class intersection_recognition_strategyDefaultTypeInternal;
extern intersection_recognition_strategyDefaultTypeInternal _intersection_recognition_strategy_default_instance_;
class lane_line_omit_frame_strategy;
class lane_line_omit_frame_strategyDefaultTypeInternal;
extern lane_line_omit_frame_strategyDefaultTypeInternal _lane_line_omit_frame_strategy_default_instance_;
class low_speed_case;
class low_speed_caseDefaultTypeInternal;
extern low_speed_caseDefaultTypeInternal _low_speed_case_default_instance_;
class parking_config;
class parking_configDefaultTypeInternal;
extern parking_configDefaultTypeInternal _parking_config_default_instance_;
class signal_light_status_strategy;
class signal_light_status_strategyDefaultTypeInternal;
extern signal_light_status_strategyDefaultTypeInternal _signal_light_status_strategy_default_instance_;
class static_case;
class static_caseDefaultTypeInternal;
extern static_caseDefaultTypeInternal _static_case_default_instance_;
class tfl_blink_suppress_strategy;
class tfl_blink_suppress_strategyDefaultTypeInternal;
extern tfl_blink_suppress_strategyDefaultTypeInternal _tfl_blink_suppress_strategy_default_instance_;
}  // namespace proto
}  // namespace sr2_0
}  // namespace xpilot
namespace xpilot {
namespace sr2_0 {
namespace proto {

// ===================================================================

class Config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.Config) */ {
 public:
  Config();
  virtual ~Config();

  Config(const Config& from);

  inline Config& operator=(const Config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Config(Config&& from) noexcept
    : Config() {
    *this = ::std::move(from);
  }

  inline Config& operator=(Config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Config* internal_default_instance() {
    return reinterpret_cast<const Config*>(
               &_Config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Config* other);
  friend void swap(Config& a, Config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Config* New() const PROTOBUF_FINAL { return New(NULL); }

  Config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Config& from);
  void MergeFrom(const Config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xpilot.sr2_0.proto.driving_config driving_config = 1;
  bool has_driving_config() const;
  void clear_driving_config();
  static const int kDrivingConfigFieldNumber = 1;
  const ::xpilot::sr2_0::proto::driving_config& driving_config() const;
  ::xpilot::sr2_0::proto::driving_config* release_driving_config();
  ::xpilot::sr2_0::proto::driving_config* mutable_driving_config();
  void set_allocated_driving_config(::xpilot::sr2_0::proto::driving_config* driving_config);

  // .xpilot.sr2_0.proto.parking_config parking_config = 2;
  bool has_parking_config() const;
  void clear_parking_config();
  static const int kParkingConfigFieldNumber = 2;
  const ::xpilot::sr2_0::proto::parking_config& parking_config() const;
  ::xpilot::sr2_0::proto::parking_config* release_parking_config();
  ::xpilot::sr2_0::proto::parking_config* mutable_parking_config();
  void set_allocated_parking_config(::xpilot::sr2_0::proto::parking_config* parking_config);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.Config)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xpilot::sr2_0::proto::driving_config* driving_config_;
  ::xpilot::sr2_0::proto::parking_config* parking_config_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsConfigImpl();
};
// -------------------------------------------------------------------

class driving_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.driving_config) */ {
 public:
  driving_config();
  virtual ~driving_config();

  driving_config(const driving_config& from);

  inline driving_config& operator=(const driving_config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  driving_config(driving_config&& from) noexcept
    : driving_config() {
    *this = ::std::move(from);
  }

  inline driving_config& operator=(driving_config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const driving_config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const driving_config* internal_default_instance() {
    return reinterpret_cast<const driving_config*>(
               &_driving_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(driving_config* other);
  friend void swap(driving_config& a, driving_config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline driving_config* New() const PROTOBUF_FINAL { return New(NULL); }

  driving_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const driving_config& from);
  void MergeFrom(const driving_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(driving_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xpilot.sr2_0.proto.dynamic_pose_filter_strategy dynamic_pose_filter_strategy = 23;
  bool has_dynamic_pose_filter_strategy() const;
  void clear_dynamic_pose_filter_strategy();
  static const int kDynamicPoseFilterStrategyFieldNumber = 23;
  const ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy& dynamic_pose_filter_strategy() const;
  ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy* release_dynamic_pose_filter_strategy();
  ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy* mutable_dynamic_pose_filter_strategy();
  void set_allocated_dynamic_pose_filter_strategy(::xpilot::sr2_0::proto::dynamic_pose_filter_strategy* dynamic_pose_filter_strategy);

  // .xpilot.sr2_0.proto.cache_pool_static_strategy cache_pool_static_strategy = 24;
  bool has_cache_pool_static_strategy() const;
  void clear_cache_pool_static_strategy();
  static const int kCachePoolStaticStrategyFieldNumber = 24;
  const ::xpilot::sr2_0::proto::cache_pool_static_strategy& cache_pool_static_strategy() const;
  ::xpilot::sr2_0::proto::cache_pool_static_strategy* release_cache_pool_static_strategy();
  ::xpilot::sr2_0::proto::cache_pool_static_strategy* mutable_cache_pool_static_strategy();
  void set_allocated_cache_pool_static_strategy(::xpilot::sr2_0::proto::cache_pool_static_strategy* cache_pool_static_strategy);

  // .xpilot.sr2_0.proto.cache_pool_dynamic_strategy cache_pool_dynamic_strategy = 25;
  bool has_cache_pool_dynamic_strategy() const;
  void clear_cache_pool_dynamic_strategy();
  static const int kCachePoolDynamicStrategyFieldNumber = 25;
  const ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy& cache_pool_dynamic_strategy() const;
  ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy* release_cache_pool_dynamic_strategy();
  ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy* mutable_cache_pool_dynamic_strategy();
  void set_allocated_cache_pool_dynamic_strategy(::xpilot::sr2_0::proto::cache_pool_dynamic_strategy* cache_pool_dynamic_strategy);

  // .xpilot.sr2_0.proto.lane_line_omit_frame_strategy lane_line_omit_frame_strategy = 26;
  bool has_lane_line_omit_frame_strategy() const;
  void clear_lane_line_omit_frame_strategy();
  static const int kLaneLineOmitFrameStrategyFieldNumber = 26;
  const ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy& lane_line_omit_frame_strategy() const;
  ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy* release_lane_line_omit_frame_strategy();
  ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy* mutable_lane_line_omit_frame_strategy();
  void set_allocated_lane_line_omit_frame_strategy(::xpilot::sr2_0::proto::lane_line_omit_frame_strategy* lane_line_omit_frame_strategy);

  // .xpilot.sr2_0.proto.signal_light_status_strategy signal_light_status_strategy = 27;
  bool has_signal_light_status_strategy() const;
  void clear_signal_light_status_strategy();
  static const int kSignalLightStatusStrategyFieldNumber = 27;
  const ::xpilot::sr2_0::proto::signal_light_status_strategy& signal_light_status_strategy() const;
  ::xpilot::sr2_0::proto::signal_light_status_strategy* release_signal_light_status_strategy();
  ::xpilot::sr2_0::proto::signal_light_status_strategy* mutable_signal_light_status_strategy();
  void set_allocated_signal_light_status_strategy(::xpilot::sr2_0::proto::signal_light_status_strategy* signal_light_status_strategy);

  // .xpilot.sr2_0.proto.intersection_recognition_strategy intersection_recognition_strategy = 28;
  bool has_intersection_recognition_strategy() const;
  void clear_intersection_recognition_strategy();
  static const int kIntersectionRecognitionStrategyFieldNumber = 28;
  const ::xpilot::sr2_0::proto::intersection_recognition_strategy& intersection_recognition_strategy() const;
  ::xpilot::sr2_0::proto::intersection_recognition_strategy* release_intersection_recognition_strategy();
  ::xpilot::sr2_0::proto::intersection_recognition_strategy* mutable_intersection_recognition_strategy();
  void set_allocated_intersection_recognition_strategy(::xpilot::sr2_0::proto::intersection_recognition_strategy* intersection_recognition_strategy);

  // .xpilot.sr2_0.proto.tfl_blink_suppress_strategy tfl_blink_suppress_strategy = 29;
  bool has_tfl_blink_suppress_strategy() const;
  void clear_tfl_blink_suppress_strategy();
  static const int kTflBlinkSuppressStrategyFieldNumber = 29;
  const ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy& tfl_blink_suppress_strategy() const;
  ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy* release_tfl_blink_suppress_strategy();
  ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy* mutable_tfl_blink_suppress_strategy();
  void set_allocated_tfl_blink_suppress_strategy(::xpilot::sr2_0::proto::tfl_blink_suppress_strategy* tfl_blink_suppress_strategy);

  // float decision_surf_idt = 1;
  void clear_decision_surf_idt();
  static const int kDecisionSurfIdtFieldNumber = 1;
  float decision_surf_idt() const;
  void set_decision_surf_idt(float value);

  // float target_color_min_dist = 2;
  void clear_target_color_min_dist();
  static const int kTargetColorMinDistFieldNumber = 2;
  float target_color_min_dist() const;
  void set_target_color_min_dist(float value);

  // float big_track_bus_min_length = 3;
  void clear_big_track_bus_min_length();
  static const int kBigTrackBusMinLengthFieldNumber = 3;
  float big_track_bus_min_length() const;
  void set_big_track_bus_min_length(float value);

  // bool log_proto_binary = 4;
  void clear_log_proto_binary();
  static const int kLogProtoBinaryFieldNumber = 4;
  bool log_proto_binary() const;
  void set_log_proto_binary(bool value);

  // bool log_stat_proto_size = 5;
  void clear_log_stat_proto_size();
  static const int kLogStatProtoSizeFieldNumber = 5;
  bool log_stat_proto_size() const;
  void set_log_stat_proto_size(bool value);

  // bool config_dedug_log = 6;
  void clear_config_dedug_log();
  static const int kConfigDedugLogFieldNumber = 6;
  bool config_dedug_log() const;
  void set_config_dedug_log(bool value);

  // bool target_color_log_open = 7;
  void clear_target_color_log_open();
  static const int kTargetColorLogOpenFieldNumber = 7;
  bool target_color_log_open() const;
  void set_target_color_log_open(bool value);

  // uint32 dynamic_obj_filter_mode = 9;
  void clear_dynamic_obj_filter_mode();
  static const int kDynamicObjFilterModeFieldNumber = 9;
  ::google::protobuf::uint32 dynamic_obj_filter_mode() const;
  void set_dynamic_obj_filter_mode(::google::protobuf::uint32 value);

  // float kalman_filter_R = 11;
  void clear_kalman_filter_r();
  static const int kKalmanFilterRFieldNumber = 11;
  float kalman_filter_r() const;
  void set_kalman_filter_r(float value);

  // float kalman_filter_Q = 12;
  void clear_kalman_filter_q();
  static const int kKalmanFilterQFieldNumber = 12;
  float kalman_filter_q() const;
  void set_kalman_filter_q(float value);

  // bool cdcu_func_check = 8;
  void clear_cdcu_func_check();
  static const int kCdcuFuncCheckFieldNumber = 8;
  bool cdcu_func_check() const;
  void set_cdcu_func_check(bool value);

  // bool dynamic_obj_filter_log_open = 10;
  void clear_dynamic_obj_filter_log_open();
  static const int kDynamicObjFilterLogOpenFieldNumber = 10;
  bool dynamic_obj_filter_log_open() const;
  void set_dynamic_obj_filter_log_open(bool value);

  // bool yaw_filter_open = 13;
  void clear_yaw_filter_open();
  static const int kYawFilterOpenFieldNumber = 13;
  bool yaw_filter_open() const;
  void set_yaw_filter_open(bool value);

  // bool type_filter_open = 18;
  void clear_type_filter_open();
  static const int kTypeFilterOpenFieldNumber = 18;
  bool type_filter_open() const;
  void set_type_filter_open(bool value);

  // uint32 yaw_filter_debug_id = 14;
  void clear_yaw_filter_debug_id();
  static const int kYawFilterDebugIdFieldNumber = 14;
  ::google::protobuf::uint32 yaw_filter_debug_id() const;
  void set_yaw_filter_debug_id(::google::protobuf::uint32 value);

  // float yaw_filter_lp_k = 15;
  void clear_yaw_filter_lp_k();
  static const int kYawFilterLpKFieldNumber = 15;
  float yaw_filter_lp_k() const;
  void set_yaw_filter_lp_k(float value);

  // float yaw_filter_static_vel = 16;
  void clear_yaw_filter_static_vel();
  static const int kYawFilterStaticVelFieldNumber = 16;
  float yaw_filter_static_vel() const;
  void set_yaw_filter_static_vel(float value);

  // uint32 yaw_filter_frame_num = 17;
  void clear_yaw_filter_frame_num();
  static const int kYawFilterFrameNumFieldNumber = 17;
  ::google::protobuf::uint32 yaw_filter_frame_num() const;
  void set_yaw_filter_frame_num(::google::protobuf::uint32 value);

  // uint32 type_filter_count = 19;
  void clear_type_filter_count();
  static const int kTypeFilterCountFieldNumber = 19;
  ::google::protobuf::uint32 type_filter_count() const;
  void set_type_filter_count(::google::protobuf::uint32 value);

  // uint32 type_filter_following_count = 20;
  void clear_type_filter_following_count();
  static const int kTypeFilterFollowingCountFieldNumber = 20;
  ::google::protobuf::uint32 type_filter_following_count() const;
  void set_type_filter_following_count(::google::protobuf::uint32 value);

  // bool lane_line_polyfit_open = 21;
  void clear_lane_line_polyfit_open();
  static const int kLaneLinePolyfitOpenFieldNumber = 21;
  bool lane_line_polyfit_open() const;
  void set_lane_line_polyfit_open(bool value);

  // bool dynamic_id_filter_open = 22;
  void clear_dynamic_id_filter_open();
  static const int kDynamicIdFilterOpenFieldNumber = 22;
  bool dynamic_id_filter_open() const;
  void set_dynamic_id_filter_open(bool value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.driving_config)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy* dynamic_pose_filter_strategy_;
  ::xpilot::sr2_0::proto::cache_pool_static_strategy* cache_pool_static_strategy_;
  ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy* cache_pool_dynamic_strategy_;
  ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy* lane_line_omit_frame_strategy_;
  ::xpilot::sr2_0::proto::signal_light_status_strategy* signal_light_status_strategy_;
  ::xpilot::sr2_0::proto::intersection_recognition_strategy* intersection_recognition_strategy_;
  ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy* tfl_blink_suppress_strategy_;
  float decision_surf_idt_;
  float target_color_min_dist_;
  float big_track_bus_min_length_;
  bool log_proto_binary_;
  bool log_stat_proto_size_;
  bool config_dedug_log_;
  bool target_color_log_open_;
  ::google::protobuf::uint32 dynamic_obj_filter_mode_;
  float kalman_filter_r_;
  float kalman_filter_q_;
  bool cdcu_func_check_;
  bool dynamic_obj_filter_log_open_;
  bool yaw_filter_open_;
  bool type_filter_open_;
  ::google::protobuf::uint32 yaw_filter_debug_id_;
  float yaw_filter_lp_k_;
  float yaw_filter_static_vel_;
  ::google::protobuf::uint32 yaw_filter_frame_num_;
  ::google::protobuf::uint32 type_filter_count_;
  ::google::protobuf::uint32 type_filter_following_count_;
  bool lane_line_polyfit_open_;
  bool dynamic_id_filter_open_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsdriving_configImpl();
};
// -------------------------------------------------------------------

class parking_config : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.parking_config) */ {
 public:
  parking_config();
  virtual ~parking_config();

  parking_config(const parking_config& from);

  inline parking_config& operator=(const parking_config& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  parking_config(parking_config&& from) noexcept
    : parking_config() {
    *this = ::std::move(from);
  }

  inline parking_config& operator=(parking_config&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const parking_config& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const parking_config* internal_default_instance() {
    return reinterpret_cast<const parking_config*>(
               &_parking_config_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(parking_config* other);
  friend void swap(parking_config& a, parking_config& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline parking_config* New() const PROTOBUF_FINAL { return New(NULL); }

  parking_config* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const parking_config& from);
  void MergeFrom(const parking_config& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(parking_config* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.parking_config)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsparking_configImpl();
};
// -------------------------------------------------------------------

class tfl_blink_suppress_strategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.tfl_blink_suppress_strategy) */ {
 public:
  tfl_blink_suppress_strategy();
  virtual ~tfl_blink_suppress_strategy();

  tfl_blink_suppress_strategy(const tfl_blink_suppress_strategy& from);

  inline tfl_blink_suppress_strategy& operator=(const tfl_blink_suppress_strategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  tfl_blink_suppress_strategy(tfl_blink_suppress_strategy&& from) noexcept
    : tfl_blink_suppress_strategy() {
    *this = ::std::move(from);
  }

  inline tfl_blink_suppress_strategy& operator=(tfl_blink_suppress_strategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const tfl_blink_suppress_strategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tfl_blink_suppress_strategy* internal_default_instance() {
    return reinterpret_cast<const tfl_blink_suppress_strategy*>(
               &_tfl_blink_suppress_strategy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(tfl_blink_suppress_strategy* other);
  friend void swap(tfl_blink_suppress_strategy& a, tfl_blink_suppress_strategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline tfl_blink_suppress_strategy* New() const PROTOBUF_FINAL { return New(NULL); }

  tfl_blink_suppress_strategy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const tfl_blink_suppress_strategy& from);
  void MergeFrom(const tfl_blink_suppress_strategy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(tfl_blink_suppress_strategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool enable = 1;
  void clear_enable();
  static const int kEnableFieldNumber = 1;
  bool enable() const;
  void set_enable(bool value);

  // uint32 frame_count = 2;
  void clear_frame_count();
  static const int kFrameCountFieldNumber = 2;
  ::google::protobuf::uint32 frame_count() const;
  void set_frame_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.tfl_blink_suppress_strategy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool enable_;
  ::google::protobuf::uint32 frame_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultstfl_blink_suppress_strategyImpl();
};
// -------------------------------------------------------------------

class intersection_recognition_strategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.intersection_recognition_strategy) */ {
 public:
  intersection_recognition_strategy();
  virtual ~intersection_recognition_strategy();

  intersection_recognition_strategy(const intersection_recognition_strategy& from);

  inline intersection_recognition_strategy& operator=(const intersection_recognition_strategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  intersection_recognition_strategy(intersection_recognition_strategy&& from) noexcept
    : intersection_recognition_strategy() {
    *this = ::std::move(from);
  }

  inline intersection_recognition_strategy& operator=(intersection_recognition_strategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const intersection_recognition_strategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const intersection_recognition_strategy* internal_default_instance() {
    return reinterpret_cast<const intersection_recognition_strategy*>(
               &_intersection_recognition_strategy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(intersection_recognition_strategy* other);
  friend void swap(intersection_recognition_strategy& a, intersection_recognition_strategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline intersection_recognition_strategy* New() const PROTOBUF_FINAL { return New(NULL); }

  intersection_recognition_strategy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const intersection_recognition_strategy& from);
  void MergeFrom(const intersection_recognition_strategy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(intersection_recognition_strategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xpilot.sr2_0.proto.drive_into_condition drive_into_condition = 4;
  bool has_drive_into_condition() const;
  void clear_drive_into_condition();
  static const int kDriveIntoConditionFieldNumber = 4;
  const ::xpilot::sr2_0::proto::drive_into_condition& drive_into_condition() const;
  ::xpilot::sr2_0::proto::drive_into_condition* release_drive_into_condition();
  ::xpilot::sr2_0::proto::drive_into_condition* mutable_drive_into_condition();
  void set_allocated_drive_into_condition(::xpilot::sr2_0::proto::drive_into_condition* drive_into_condition);

  // .xpilot.sr2_0.proto.drive_out_condition drive_out_condition = 5;
  bool has_drive_out_condition() const;
  void clear_drive_out_condition();
  static const int kDriveOutConditionFieldNumber = 5;
  const ::xpilot::sr2_0::proto::drive_out_condition& drive_out_condition() const;
  ::xpilot::sr2_0::proto::drive_out_condition* release_drive_out_condition();
  ::xpilot::sr2_0::proto::drive_out_condition* mutable_drive_out_condition();
  void set_allocated_drive_out_condition(::xpilot::sr2_0::proto::drive_out_condition* drive_out_condition);

  // bool enable = 1;
  void clear_enable();
  static const int kEnableFieldNumber = 1;
  bool enable() const;
  void set_enable(bool value);

  // bool debug_log = 2;
  void clear_debug_log();
  static const int kDebugLogFieldNumber = 2;
  bool debug_log() const;
  void set_debug_log(bool value);

  // float speed_limit = 3;
  void clear_speed_limit();
  static const int kSpeedLimitFieldNumber = 3;
  float speed_limit() const;
  void set_speed_limit(float value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.intersection_recognition_strategy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xpilot::sr2_0::proto::drive_into_condition* drive_into_condition_;
  ::xpilot::sr2_0::proto::drive_out_condition* drive_out_condition_;
  bool enable_;
  bool debug_log_;
  float speed_limit_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsintersection_recognition_strategyImpl();
};
// -------------------------------------------------------------------

class drive_into_condition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.drive_into_condition) */ {
 public:
  drive_into_condition();
  virtual ~drive_into_condition();

  drive_into_condition(const drive_into_condition& from);

  inline drive_into_condition& operator=(const drive_into_condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  drive_into_condition(drive_into_condition&& from) noexcept
    : drive_into_condition() {
    *this = ::std::move(from);
  }

  inline drive_into_condition& operator=(drive_into_condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const drive_into_condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const drive_into_condition* internal_default_instance() {
    return reinterpret_cast<const drive_into_condition*>(
               &_drive_into_condition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(drive_into_condition* other);
  friend void swap(drive_into_condition& a, drive_into_condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline drive_into_condition* New() const PROTOBUF_FINAL { return New(NULL); }

  drive_into_condition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const drive_into_condition& from);
  void MergeFrom(const drive_into_condition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(drive_into_condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float dist_road_mark = 1;
  void clear_dist_road_mark();
  static const int kDistRoadMarkFieldNumber = 1;
  float dist_road_mark() const;
  void set_dist_road_mark(float value);

  // float length_road_mark = 2;
  void clear_length_road_mark();
  static const int kLengthRoadMarkFieldNumber = 2;
  float length_road_mark() const;
  void set_length_road_mark(float value);

  // float width_lane = 3;
  void clear_width_lane();
  static const int kWidthLaneFieldNumber = 3;
  float width_lane() const;
  void set_width_lane(float value);

  // uint32 length_search_laneline = 4;
  void clear_length_search_laneline();
  static const int kLengthSearchLanelineFieldNumber = 4;
  ::google::protobuf::uint32 length_search_laneline() const;
  void set_length_search_laneline(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.drive_into_condition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float dist_road_mark_;
  float length_road_mark_;
  float width_lane_;
  ::google::protobuf::uint32 length_search_laneline_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsdrive_into_conditionImpl();
};
// -------------------------------------------------------------------

class drive_out_condition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.drive_out_condition) */ {
 public:
  drive_out_condition();
  virtual ~drive_out_condition();

  drive_out_condition(const drive_out_condition& from);

  inline drive_out_condition& operator=(const drive_out_condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  drive_out_condition(drive_out_condition&& from) noexcept
    : drive_out_condition() {
    *this = ::std::move(from);
  }

  inline drive_out_condition& operator=(drive_out_condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const drive_out_condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const drive_out_condition* internal_default_instance() {
    return reinterpret_cast<const drive_out_condition*>(
               &_drive_out_condition_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(drive_out_condition* other);
  friend void swap(drive_out_condition& a, drive_out_condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline drive_out_condition* New() const PROTOBUF_FINAL { return New(NULL); }

  drive_out_condition* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const drive_out_condition& from);
  void MergeFrom(const drive_out_condition& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(drive_out_condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 dist_ego_drive = 1;
  void clear_dist_ego_drive();
  static const int kDistEgoDriveFieldNumber = 1;
  ::google::protobuf::uint32 dist_ego_drive() const;
  void set_dist_ego_drive(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.drive_out_condition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 dist_ego_drive_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsdrive_out_conditionImpl();
};
// -------------------------------------------------------------------

class signal_light_status_strategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.signal_light_status_strategy) */ {
 public:
  signal_light_status_strategy();
  virtual ~signal_light_status_strategy();

  signal_light_status_strategy(const signal_light_status_strategy& from);

  inline signal_light_status_strategy& operator=(const signal_light_status_strategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  signal_light_status_strategy(signal_light_status_strategy&& from) noexcept
    : signal_light_status_strategy() {
    *this = ::std::move(from);
  }

  inline signal_light_status_strategy& operator=(signal_light_status_strategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const signal_light_status_strategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const signal_light_status_strategy* internal_default_instance() {
    return reinterpret_cast<const signal_light_status_strategy*>(
               &_signal_light_status_strategy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(signal_light_status_strategy* other);
  friend void swap(signal_light_status_strategy& a, signal_light_status_strategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline signal_light_status_strategy* New() const PROTOBUF_FINAL { return New(NULL); }

  signal_light_status_strategy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const signal_light_status_strategy& from);
  void MergeFrom(const signal_light_status_strategy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(signal_light_status_strategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool open = 1;
  void clear_open();
  static const int kOpenFieldNumber = 1;
  bool open() const;
  void set_open(bool value);

  // bool yaw_dirction_debug = 2;
  void clear_yaw_dirction_debug();
  static const int kYawDirctionDebugFieldNumber = 2;
  bool yaw_dirction_debug() const;
  void set_yaw_dirction_debug(bool value);

  // float yaw_dirction_left = 3;
  void clear_yaw_dirction_left();
  static const int kYawDirctionLeftFieldNumber = 3;
  float yaw_dirction_left() const;
  void set_yaw_dirction_left(float value);

  // float yaw_dirction_right = 4;
  void clear_yaw_dirction_right();
  static const int kYawDirctionRightFieldNumber = 4;
  float yaw_dirction_right() const;
  void set_yaw_dirction_right(float value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.signal_light_status_strategy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool open_;
  bool yaw_dirction_debug_;
  float yaw_dirction_left_;
  float yaw_dirction_right_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultssignal_light_status_strategyImpl();
};
// -------------------------------------------------------------------

class cache_pool_dynamic_strategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.cache_pool_dynamic_strategy) */ {
 public:
  cache_pool_dynamic_strategy();
  virtual ~cache_pool_dynamic_strategy();

  cache_pool_dynamic_strategy(const cache_pool_dynamic_strategy& from);

  inline cache_pool_dynamic_strategy& operator=(const cache_pool_dynamic_strategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  cache_pool_dynamic_strategy(cache_pool_dynamic_strategy&& from) noexcept
    : cache_pool_dynamic_strategy() {
    *this = ::std::move(from);
  }

  inline cache_pool_dynamic_strategy& operator=(cache_pool_dynamic_strategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const cache_pool_dynamic_strategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const cache_pool_dynamic_strategy* internal_default_instance() {
    return reinterpret_cast<const cache_pool_dynamic_strategy*>(
               &_cache_pool_dynamic_strategy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(cache_pool_dynamic_strategy* other);
  friend void swap(cache_pool_dynamic_strategy& a, cache_pool_dynamic_strategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline cache_pool_dynamic_strategy* New() const PROTOBUF_FINAL { return New(NULL); }

  cache_pool_dynamic_strategy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const cache_pool_dynamic_strategy& from);
  void MergeFrom(const cache_pool_dynamic_strategy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(cache_pool_dynamic_strategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool open = 1;
  void clear_open();
  static const int kOpenFieldNumber = 1;
  bool open() const;
  void set_open(bool value);

  // bool yaw_dirction_debug = 2;
  void clear_yaw_dirction_debug();
  static const int kYawDirctionDebugFieldNumber = 2;
  bool yaw_dirction_debug() const;
  void set_yaw_dirction_debug(bool value);

  // float yaw_dirction_left = 3;
  void clear_yaw_dirction_left();
  static const int kYawDirctionLeftFieldNumber = 3;
  float yaw_dirction_left() const;
  void set_yaw_dirction_left(float value);

  // float yaw_dirction_right = 4;
  void clear_yaw_dirction_right();
  static const int kYawDirctionRightFieldNumber = 4;
  float yaw_dirction_right() const;
  void set_yaw_dirction_right(float value);

  // uint32 run_cache_count = 5;
  void clear_run_cache_count();
  static const int kRunCacheCountFieldNumber = 5;
  ::google::protobuf::uint32 run_cache_count() const;
  void set_run_cache_count(::google::protobuf::uint32 value);

  // uint32 stop_cache_count = 6;
  void clear_stop_cache_count();
  static const int kStopCacheCountFieldNumber = 6;
  ::google::protobuf::uint32 stop_cache_count() const;
  void set_stop_cache_count(::google::protobuf::uint32 value);

  // float self_vehicle_stop_speed = 7;
  void clear_self_vehicle_stop_speed();
  static const int kSelfVehicleStopSpeedFieldNumber = 7;
  float self_vehicle_stop_speed() const;
  void set_self_vehicle_stop_speed(float value);

  // float union_rate_min = 8;
  void clear_union_rate_min();
  static const int kUnionRateMinFieldNumber = 8;
  float union_rate_min() const;
  void set_union_rate_min(float value);

  // float update_max_velocity = 9;
  void clear_update_max_velocity();
  static const int kUpdateMaxVelocityFieldNumber = 9;
  float update_max_velocity() const;
  void set_update_max_velocity(float value);

  // float update_max_distance = 10;
  void clear_update_max_distance();
  static const int kUpdateMaxDistanceFieldNumber = 10;
  float update_max_distance() const;
  void set_update_max_distance(float value);

  // float check_delta_dist = 11;
  void clear_check_delta_dist();
  static const int kCheckDeltaDistFieldNumber = 11;
  float check_delta_dist() const;
  void set_check_delta_dist(float value);

  // float check_delta_time = 12;
  void clear_check_delta_time();
  static const int kCheckDeltaTimeFieldNumber = 12;
  float check_delta_time() const;
  void set_check_delta_time(float value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.cache_pool_dynamic_strategy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool open_;
  bool yaw_dirction_debug_;
  float yaw_dirction_left_;
  float yaw_dirction_right_;
  ::google::protobuf::uint32 run_cache_count_;
  ::google::protobuf::uint32 stop_cache_count_;
  float self_vehicle_stop_speed_;
  float union_rate_min_;
  float update_max_velocity_;
  float update_max_distance_;
  float check_delta_dist_;
  float check_delta_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultscache_pool_dynamic_strategyImpl();
};
// -------------------------------------------------------------------

class cache_pool_static_strategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.cache_pool_static_strategy) */ {
 public:
  cache_pool_static_strategy();
  virtual ~cache_pool_static_strategy();

  cache_pool_static_strategy(const cache_pool_static_strategy& from);

  inline cache_pool_static_strategy& operator=(const cache_pool_static_strategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  cache_pool_static_strategy(cache_pool_static_strategy&& from) noexcept
    : cache_pool_static_strategy() {
    *this = ::std::move(from);
  }

  inline cache_pool_static_strategy& operator=(cache_pool_static_strategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const cache_pool_static_strategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const cache_pool_static_strategy* internal_default_instance() {
    return reinterpret_cast<const cache_pool_static_strategy*>(
               &_cache_pool_static_strategy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(cache_pool_static_strategy* other);
  friend void swap(cache_pool_static_strategy& a, cache_pool_static_strategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline cache_pool_static_strategy* New() const PROTOBUF_FINAL { return New(NULL); }

  cache_pool_static_strategy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const cache_pool_static_strategy& from);
  void MergeFrom(const cache_pool_static_strategy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(cache_pool_static_strategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool open = 1;
  void clear_open();
  static const int kOpenFieldNumber = 1;
  bool open() const;
  void set_open(bool value);

  // bool open_sod = 2;
  void clear_open_sod();
  static const int kOpenSodFieldNumber = 2;
  bool open_sod() const;
  void set_open_sod(bool value);

  // uint32 cache_count = 3;
  void clear_cache_count();
  static const int kCacheCountFieldNumber = 3;
  ::google::protobuf::uint32 cache_count() const;
  void set_cache_count(::google::protobuf::uint32 value);

  // float min_dist = 4;
  void clear_min_dist();
  static const int kMinDistFieldNumber = 4;
  float min_dist() const;
  void set_min_dist(float value);

  // float check_delta_dist = 5;
  void clear_check_delta_dist();
  static const int kCheckDeltaDistFieldNumber = 5;
  float check_delta_dist() const;
  void set_check_delta_dist(float value);

  // float check_delta_time = 6;
  void clear_check_delta_time();
  static const int kCheckDeltaTimeFieldNumber = 6;
  float check_delta_time() const;
  void set_check_delta_time(float value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.cache_pool_static_strategy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool open_;
  bool open_sod_;
  ::google::protobuf::uint32 cache_count_;
  float min_dist_;
  float check_delta_dist_;
  float check_delta_time_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultscache_pool_static_strategyImpl();
};
// -------------------------------------------------------------------

class dynamic_pose_filter_strategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.dynamic_pose_filter_strategy) */ {
 public:
  dynamic_pose_filter_strategy();
  virtual ~dynamic_pose_filter_strategy();

  dynamic_pose_filter_strategy(const dynamic_pose_filter_strategy& from);

  inline dynamic_pose_filter_strategy& operator=(const dynamic_pose_filter_strategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  dynamic_pose_filter_strategy(dynamic_pose_filter_strategy&& from) noexcept
    : dynamic_pose_filter_strategy() {
    *this = ::std::move(from);
  }

  inline dynamic_pose_filter_strategy& operator=(dynamic_pose_filter_strategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const dynamic_pose_filter_strategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dynamic_pose_filter_strategy* internal_default_instance() {
    return reinterpret_cast<const dynamic_pose_filter_strategy*>(
               &_dynamic_pose_filter_strategy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(dynamic_pose_filter_strategy* other);
  friend void swap(dynamic_pose_filter_strategy& a, dynamic_pose_filter_strategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline dynamic_pose_filter_strategy* New() const PROTOBUF_FINAL { return New(NULL); }

  dynamic_pose_filter_strategy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const dynamic_pose_filter_strategy& from);
  void MergeFrom(const dynamic_pose_filter_strategy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(dynamic_pose_filter_strategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool open = 1;
  void clear_open();
  static const int kOpenFieldNumber = 1;
  bool open() const;
  void set_open(bool value);

  // uint32 cache_count = 2;
  void clear_cache_count();
  static const int kCacheCountFieldNumber = 2;
  ::google::protobuf::uint32 cache_count() const;
  void set_cache_count(::google::protobuf::uint32 value);

  // float vehicle_stop_speed = 3;
  void clear_vehicle_stop_speed();
  static const int kVehicleStopSpeedFieldNumber = 3;
  float vehicle_stop_speed() const;
  void set_vehicle_stop_speed(float value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.dynamic_pose_filter_strategy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool open_;
  ::google::protobuf::uint32 cache_count_;
  float vehicle_stop_speed_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsdynamic_pose_filter_strategyImpl();
};
// -------------------------------------------------------------------

class lane_line_omit_frame_strategy : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.lane_line_omit_frame_strategy) */ {
 public:
  lane_line_omit_frame_strategy();
  virtual ~lane_line_omit_frame_strategy();

  lane_line_omit_frame_strategy(const lane_line_omit_frame_strategy& from);

  inline lane_line_omit_frame_strategy& operator=(const lane_line_omit_frame_strategy& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  lane_line_omit_frame_strategy(lane_line_omit_frame_strategy&& from) noexcept
    : lane_line_omit_frame_strategy() {
    *this = ::std::move(from);
  }

  inline lane_line_omit_frame_strategy& operator=(lane_line_omit_frame_strategy&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const lane_line_omit_frame_strategy& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const lane_line_omit_frame_strategy* internal_default_instance() {
    return reinterpret_cast<const lane_line_omit_frame_strategy*>(
               &_lane_line_omit_frame_strategy_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(lane_line_omit_frame_strategy* other);
  friend void swap(lane_line_omit_frame_strategy& a, lane_line_omit_frame_strategy& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline lane_line_omit_frame_strategy* New() const PROTOBUF_FINAL { return New(NULL); }

  lane_line_omit_frame_strategy* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const lane_line_omit_frame_strategy& from);
  void MergeFrom(const lane_line_omit_frame_strategy& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(lane_line_omit_frame_strategy* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xpilot.sr2_0.proto.low_speed_case low_speed_case = 2;
  bool has_low_speed_case() const;
  void clear_low_speed_case();
  static const int kLowSpeedCaseFieldNumber = 2;
  const ::xpilot::sr2_0::proto::low_speed_case& low_speed_case() const;
  ::xpilot::sr2_0::proto::low_speed_case* release_low_speed_case();
  ::xpilot::sr2_0::proto::low_speed_case* mutable_low_speed_case();
  void set_allocated_low_speed_case(::xpilot::sr2_0::proto::low_speed_case* low_speed_case);

  // .xpilot.sr2_0.proto.static_case static_case = 3;
  bool has_static_case() const;
  void clear_static_case();
  static const int kStaticCaseFieldNumber = 3;
  const ::xpilot::sr2_0::proto::static_case& static_case() const;
  ::xpilot::sr2_0::proto::static_case* release_static_case();
  ::xpilot::sr2_0::proto::static_case* mutable_static_case();
  void set_allocated_static_case(::xpilot::sr2_0::proto::static_case* static_case);

  // bool enable = 1;
  void clear_enable();
  static const int kEnableFieldNumber = 1;
  bool enable() const;
  void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.lane_line_omit_frame_strategy)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xpilot::sr2_0::proto::low_speed_case* low_speed_case_;
  ::xpilot::sr2_0::proto::static_case* static_case_;
  bool enable_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultslane_line_omit_frame_strategyImpl();
};
// -------------------------------------------------------------------

class low_speed_case : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.low_speed_case) */ {
 public:
  low_speed_case();
  virtual ~low_speed_case();

  low_speed_case(const low_speed_case& from);

  inline low_speed_case& operator=(const low_speed_case& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  low_speed_case(low_speed_case&& from) noexcept
    : low_speed_case() {
    *this = ::std::move(from);
  }

  inline low_speed_case& operator=(low_speed_case&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const low_speed_case& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const low_speed_case* internal_default_instance() {
    return reinterpret_cast<const low_speed_case*>(
               &_low_speed_case_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(low_speed_case* other);
  friend void swap(low_speed_case& a, low_speed_case& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline low_speed_case* New() const PROTOBUF_FINAL { return New(NULL); }

  low_speed_case* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const low_speed_case& from);
  void MergeFrom(const low_speed_case& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(low_speed_case* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 frame_count = 1;
  void clear_frame_count();
  static const int kFrameCountFieldNumber = 1;
  ::google::protobuf::uint32 frame_count() const;
  void set_frame_count(::google::protobuf::uint32 value);

  // float speed_ceiling = 2;
  void clear_speed_ceiling();
  static const int kSpeedCeilingFieldNumber = 2;
  float speed_ceiling() const;
  void set_speed_ceiling(float value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.low_speed_case)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 frame_count_;
  float speed_ceiling_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultslow_speed_caseImpl();
};
// -------------------------------------------------------------------

class static_case : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xpilot.sr2_0.proto.static_case) */ {
 public:
  static_case();
  virtual ~static_case();

  static_case(const static_case& from);

  inline static_case& operator=(const static_case& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  static_case(static_case&& from) noexcept
    : static_case() {
    *this = ::std::move(from);
  }

  inline static_case& operator=(static_case&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const static_case& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const static_case* internal_default_instance() {
    return reinterpret_cast<const static_case*>(
               &_static_case_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(static_case* other);
  friend void swap(static_case& a, static_case& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline static_case* New() const PROTOBUF_FINAL { return New(NULL); }

  static_case* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const static_case& from);
  void MergeFrom(const static_case& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(static_case* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 frame_count = 1;
  void clear_frame_count();
  static const int kFrameCountFieldNumber = 1;
  ::google::protobuf::uint32 frame_count() const;
  void set_frame_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xpilot.sr2_0.proto.static_case)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 frame_count_;
  mutable int _cached_size_;
  friend struct ::protobuf_addressbook_2eproto::TableStruct;
  friend void ::protobuf_addressbook_2eproto::InitDefaultsstatic_caseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Config

// .xpilot.sr2_0.proto.driving_config driving_config = 1;
inline bool Config::has_driving_config() const {
  return this != internal_default_instance() && driving_config_ != NULL;
}
inline void Config::clear_driving_config() {
  if (GetArenaNoVirtual() == NULL && driving_config_ != NULL) {
    delete driving_config_;
  }
  driving_config_ = NULL;
}
inline const ::xpilot::sr2_0::proto::driving_config& Config::driving_config() const {
  const ::xpilot::sr2_0::proto::driving_config* p = driving_config_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.Config.driving_config)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::driving_config*>(
      &::xpilot::sr2_0::proto::_driving_config_default_instance_);
}
inline ::xpilot::sr2_0::proto::driving_config* Config::release_driving_config() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.Config.driving_config)
  
  ::xpilot::sr2_0::proto::driving_config* temp = driving_config_;
  driving_config_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::driving_config* Config::mutable_driving_config() {
  
  if (driving_config_ == NULL) {
    driving_config_ = new ::xpilot::sr2_0::proto::driving_config;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.Config.driving_config)
  return driving_config_;
}
inline void Config::set_allocated_driving_config(::xpilot::sr2_0::proto::driving_config* driving_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete driving_config_;
  }
  if (driving_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      driving_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, driving_config, submessage_arena);
    }
    
  } else {
    
  }
  driving_config_ = driving_config;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.Config.driving_config)
}

// .xpilot.sr2_0.proto.parking_config parking_config = 2;
inline bool Config::has_parking_config() const {
  return this != internal_default_instance() && parking_config_ != NULL;
}
inline void Config::clear_parking_config() {
  if (GetArenaNoVirtual() == NULL && parking_config_ != NULL) {
    delete parking_config_;
  }
  parking_config_ = NULL;
}
inline const ::xpilot::sr2_0::proto::parking_config& Config::parking_config() const {
  const ::xpilot::sr2_0::proto::parking_config* p = parking_config_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.Config.parking_config)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::parking_config*>(
      &::xpilot::sr2_0::proto::_parking_config_default_instance_);
}
inline ::xpilot::sr2_0::proto::parking_config* Config::release_parking_config() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.Config.parking_config)
  
  ::xpilot::sr2_0::proto::parking_config* temp = parking_config_;
  parking_config_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::parking_config* Config::mutable_parking_config() {
  
  if (parking_config_ == NULL) {
    parking_config_ = new ::xpilot::sr2_0::proto::parking_config;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.Config.parking_config)
  return parking_config_;
}
inline void Config::set_allocated_parking_config(::xpilot::sr2_0::proto::parking_config* parking_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parking_config_;
  }
  if (parking_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parking_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parking_config, submessage_arena);
    }
    
  } else {
    
  }
  parking_config_ = parking_config;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.Config.parking_config)
}

// -------------------------------------------------------------------

// driving_config

// float decision_surf_idt = 1;
inline void driving_config::clear_decision_surf_idt() {
  decision_surf_idt_ = 0;
}
inline float driving_config::decision_surf_idt() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.decision_surf_idt)
  return decision_surf_idt_;
}
inline void driving_config::set_decision_surf_idt(float value) {
  
  decision_surf_idt_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.decision_surf_idt)
}

// float target_color_min_dist = 2;
inline void driving_config::clear_target_color_min_dist() {
  target_color_min_dist_ = 0;
}
inline float driving_config::target_color_min_dist() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.target_color_min_dist)
  return target_color_min_dist_;
}
inline void driving_config::set_target_color_min_dist(float value) {
  
  target_color_min_dist_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.target_color_min_dist)
}

// float big_track_bus_min_length = 3;
inline void driving_config::clear_big_track_bus_min_length() {
  big_track_bus_min_length_ = 0;
}
inline float driving_config::big_track_bus_min_length() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.big_track_bus_min_length)
  return big_track_bus_min_length_;
}
inline void driving_config::set_big_track_bus_min_length(float value) {
  
  big_track_bus_min_length_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.big_track_bus_min_length)
}

// bool log_proto_binary = 4;
inline void driving_config::clear_log_proto_binary() {
  log_proto_binary_ = false;
}
inline bool driving_config::log_proto_binary() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.log_proto_binary)
  return log_proto_binary_;
}
inline void driving_config::set_log_proto_binary(bool value) {
  
  log_proto_binary_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.log_proto_binary)
}

// bool log_stat_proto_size = 5;
inline void driving_config::clear_log_stat_proto_size() {
  log_stat_proto_size_ = false;
}
inline bool driving_config::log_stat_proto_size() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.log_stat_proto_size)
  return log_stat_proto_size_;
}
inline void driving_config::set_log_stat_proto_size(bool value) {
  
  log_stat_proto_size_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.log_stat_proto_size)
}

// bool config_dedug_log = 6;
inline void driving_config::clear_config_dedug_log() {
  config_dedug_log_ = false;
}
inline bool driving_config::config_dedug_log() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.config_dedug_log)
  return config_dedug_log_;
}
inline void driving_config::set_config_dedug_log(bool value) {
  
  config_dedug_log_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.config_dedug_log)
}

// bool target_color_log_open = 7;
inline void driving_config::clear_target_color_log_open() {
  target_color_log_open_ = false;
}
inline bool driving_config::target_color_log_open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.target_color_log_open)
  return target_color_log_open_;
}
inline void driving_config::set_target_color_log_open(bool value) {
  
  target_color_log_open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.target_color_log_open)
}

// bool cdcu_func_check = 8;
inline void driving_config::clear_cdcu_func_check() {
  cdcu_func_check_ = false;
}
inline bool driving_config::cdcu_func_check() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.cdcu_func_check)
  return cdcu_func_check_;
}
inline void driving_config::set_cdcu_func_check(bool value) {
  
  cdcu_func_check_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.cdcu_func_check)
}

// uint32 dynamic_obj_filter_mode = 9;
inline void driving_config::clear_dynamic_obj_filter_mode() {
  dynamic_obj_filter_mode_ = 0u;
}
inline ::google::protobuf::uint32 driving_config::dynamic_obj_filter_mode() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.dynamic_obj_filter_mode)
  return dynamic_obj_filter_mode_;
}
inline void driving_config::set_dynamic_obj_filter_mode(::google::protobuf::uint32 value) {
  
  dynamic_obj_filter_mode_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.dynamic_obj_filter_mode)
}

// bool dynamic_obj_filter_log_open = 10;
inline void driving_config::clear_dynamic_obj_filter_log_open() {
  dynamic_obj_filter_log_open_ = false;
}
inline bool driving_config::dynamic_obj_filter_log_open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.dynamic_obj_filter_log_open)
  return dynamic_obj_filter_log_open_;
}
inline void driving_config::set_dynamic_obj_filter_log_open(bool value) {
  
  dynamic_obj_filter_log_open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.dynamic_obj_filter_log_open)
}

// float kalman_filter_R = 11;
inline void driving_config::clear_kalman_filter_r() {
  kalman_filter_r_ = 0;
}
inline float driving_config::kalman_filter_r() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.kalman_filter_R)
  return kalman_filter_r_;
}
inline void driving_config::set_kalman_filter_r(float value) {
  
  kalman_filter_r_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.kalman_filter_R)
}

// float kalman_filter_Q = 12;
inline void driving_config::clear_kalman_filter_q() {
  kalman_filter_q_ = 0;
}
inline float driving_config::kalman_filter_q() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.kalman_filter_Q)
  return kalman_filter_q_;
}
inline void driving_config::set_kalman_filter_q(float value) {
  
  kalman_filter_q_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.kalman_filter_Q)
}

// bool yaw_filter_open = 13;
inline void driving_config::clear_yaw_filter_open() {
  yaw_filter_open_ = false;
}
inline bool driving_config::yaw_filter_open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.yaw_filter_open)
  return yaw_filter_open_;
}
inline void driving_config::set_yaw_filter_open(bool value) {
  
  yaw_filter_open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.yaw_filter_open)
}

// uint32 yaw_filter_debug_id = 14;
inline void driving_config::clear_yaw_filter_debug_id() {
  yaw_filter_debug_id_ = 0u;
}
inline ::google::protobuf::uint32 driving_config::yaw_filter_debug_id() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.yaw_filter_debug_id)
  return yaw_filter_debug_id_;
}
inline void driving_config::set_yaw_filter_debug_id(::google::protobuf::uint32 value) {
  
  yaw_filter_debug_id_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.yaw_filter_debug_id)
}

// float yaw_filter_lp_k = 15;
inline void driving_config::clear_yaw_filter_lp_k() {
  yaw_filter_lp_k_ = 0;
}
inline float driving_config::yaw_filter_lp_k() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.yaw_filter_lp_k)
  return yaw_filter_lp_k_;
}
inline void driving_config::set_yaw_filter_lp_k(float value) {
  
  yaw_filter_lp_k_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.yaw_filter_lp_k)
}

// float yaw_filter_static_vel = 16;
inline void driving_config::clear_yaw_filter_static_vel() {
  yaw_filter_static_vel_ = 0;
}
inline float driving_config::yaw_filter_static_vel() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.yaw_filter_static_vel)
  return yaw_filter_static_vel_;
}
inline void driving_config::set_yaw_filter_static_vel(float value) {
  
  yaw_filter_static_vel_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.yaw_filter_static_vel)
}

// uint32 yaw_filter_frame_num = 17;
inline void driving_config::clear_yaw_filter_frame_num() {
  yaw_filter_frame_num_ = 0u;
}
inline ::google::protobuf::uint32 driving_config::yaw_filter_frame_num() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.yaw_filter_frame_num)
  return yaw_filter_frame_num_;
}
inline void driving_config::set_yaw_filter_frame_num(::google::protobuf::uint32 value) {
  
  yaw_filter_frame_num_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.yaw_filter_frame_num)
}

// bool type_filter_open = 18;
inline void driving_config::clear_type_filter_open() {
  type_filter_open_ = false;
}
inline bool driving_config::type_filter_open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.type_filter_open)
  return type_filter_open_;
}
inline void driving_config::set_type_filter_open(bool value) {
  
  type_filter_open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.type_filter_open)
}

// uint32 type_filter_count = 19;
inline void driving_config::clear_type_filter_count() {
  type_filter_count_ = 0u;
}
inline ::google::protobuf::uint32 driving_config::type_filter_count() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.type_filter_count)
  return type_filter_count_;
}
inline void driving_config::set_type_filter_count(::google::protobuf::uint32 value) {
  
  type_filter_count_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.type_filter_count)
}

// uint32 type_filter_following_count = 20;
inline void driving_config::clear_type_filter_following_count() {
  type_filter_following_count_ = 0u;
}
inline ::google::protobuf::uint32 driving_config::type_filter_following_count() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.type_filter_following_count)
  return type_filter_following_count_;
}
inline void driving_config::set_type_filter_following_count(::google::protobuf::uint32 value) {
  
  type_filter_following_count_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.type_filter_following_count)
}

// bool lane_line_polyfit_open = 21;
inline void driving_config::clear_lane_line_polyfit_open() {
  lane_line_polyfit_open_ = false;
}
inline bool driving_config::lane_line_polyfit_open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.lane_line_polyfit_open)
  return lane_line_polyfit_open_;
}
inline void driving_config::set_lane_line_polyfit_open(bool value) {
  
  lane_line_polyfit_open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.lane_line_polyfit_open)
}

// bool dynamic_id_filter_open = 22;
inline void driving_config::clear_dynamic_id_filter_open() {
  dynamic_id_filter_open_ = false;
}
inline bool driving_config::dynamic_id_filter_open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.dynamic_id_filter_open)
  return dynamic_id_filter_open_;
}
inline void driving_config::set_dynamic_id_filter_open(bool value) {
  
  dynamic_id_filter_open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.driving_config.dynamic_id_filter_open)
}

// .xpilot.sr2_0.proto.dynamic_pose_filter_strategy dynamic_pose_filter_strategy = 23;
inline bool driving_config::has_dynamic_pose_filter_strategy() const {
  return this != internal_default_instance() && dynamic_pose_filter_strategy_ != NULL;
}
inline void driving_config::clear_dynamic_pose_filter_strategy() {
  if (GetArenaNoVirtual() == NULL && dynamic_pose_filter_strategy_ != NULL) {
    delete dynamic_pose_filter_strategy_;
  }
  dynamic_pose_filter_strategy_ = NULL;
}
inline const ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy& driving_config::dynamic_pose_filter_strategy() const {
  const ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy* p = dynamic_pose_filter_strategy_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.dynamic_pose_filter_strategy)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy*>(
      &::xpilot::sr2_0::proto::_dynamic_pose_filter_strategy_default_instance_);
}
inline ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy* driving_config::release_dynamic_pose_filter_strategy() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.driving_config.dynamic_pose_filter_strategy)
  
  ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy* temp = dynamic_pose_filter_strategy_;
  dynamic_pose_filter_strategy_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy* driving_config::mutable_dynamic_pose_filter_strategy() {
  
  if (dynamic_pose_filter_strategy_ == NULL) {
    dynamic_pose_filter_strategy_ = new ::xpilot::sr2_0::proto::dynamic_pose_filter_strategy;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.driving_config.dynamic_pose_filter_strategy)
  return dynamic_pose_filter_strategy_;
}
inline void driving_config::set_allocated_dynamic_pose_filter_strategy(::xpilot::sr2_0::proto::dynamic_pose_filter_strategy* dynamic_pose_filter_strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dynamic_pose_filter_strategy_;
  }
  if (dynamic_pose_filter_strategy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dynamic_pose_filter_strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dynamic_pose_filter_strategy, submessage_arena);
    }
    
  } else {
    
  }
  dynamic_pose_filter_strategy_ = dynamic_pose_filter_strategy;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.driving_config.dynamic_pose_filter_strategy)
}

// .xpilot.sr2_0.proto.cache_pool_static_strategy cache_pool_static_strategy = 24;
inline bool driving_config::has_cache_pool_static_strategy() const {
  return this != internal_default_instance() && cache_pool_static_strategy_ != NULL;
}
inline void driving_config::clear_cache_pool_static_strategy() {
  if (GetArenaNoVirtual() == NULL && cache_pool_static_strategy_ != NULL) {
    delete cache_pool_static_strategy_;
  }
  cache_pool_static_strategy_ = NULL;
}
inline const ::xpilot::sr2_0::proto::cache_pool_static_strategy& driving_config::cache_pool_static_strategy() const {
  const ::xpilot::sr2_0::proto::cache_pool_static_strategy* p = cache_pool_static_strategy_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.cache_pool_static_strategy)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::cache_pool_static_strategy*>(
      &::xpilot::sr2_0::proto::_cache_pool_static_strategy_default_instance_);
}
inline ::xpilot::sr2_0::proto::cache_pool_static_strategy* driving_config::release_cache_pool_static_strategy() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.driving_config.cache_pool_static_strategy)
  
  ::xpilot::sr2_0::proto::cache_pool_static_strategy* temp = cache_pool_static_strategy_;
  cache_pool_static_strategy_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::cache_pool_static_strategy* driving_config::mutable_cache_pool_static_strategy() {
  
  if (cache_pool_static_strategy_ == NULL) {
    cache_pool_static_strategy_ = new ::xpilot::sr2_0::proto::cache_pool_static_strategy;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.driving_config.cache_pool_static_strategy)
  return cache_pool_static_strategy_;
}
inline void driving_config::set_allocated_cache_pool_static_strategy(::xpilot::sr2_0::proto::cache_pool_static_strategy* cache_pool_static_strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cache_pool_static_strategy_;
  }
  if (cache_pool_static_strategy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cache_pool_static_strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cache_pool_static_strategy, submessage_arena);
    }
    
  } else {
    
  }
  cache_pool_static_strategy_ = cache_pool_static_strategy;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.driving_config.cache_pool_static_strategy)
}

// .xpilot.sr2_0.proto.cache_pool_dynamic_strategy cache_pool_dynamic_strategy = 25;
inline bool driving_config::has_cache_pool_dynamic_strategy() const {
  return this != internal_default_instance() && cache_pool_dynamic_strategy_ != NULL;
}
inline void driving_config::clear_cache_pool_dynamic_strategy() {
  if (GetArenaNoVirtual() == NULL && cache_pool_dynamic_strategy_ != NULL) {
    delete cache_pool_dynamic_strategy_;
  }
  cache_pool_dynamic_strategy_ = NULL;
}
inline const ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy& driving_config::cache_pool_dynamic_strategy() const {
  const ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy* p = cache_pool_dynamic_strategy_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.cache_pool_dynamic_strategy)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy*>(
      &::xpilot::sr2_0::proto::_cache_pool_dynamic_strategy_default_instance_);
}
inline ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy* driving_config::release_cache_pool_dynamic_strategy() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.driving_config.cache_pool_dynamic_strategy)
  
  ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy* temp = cache_pool_dynamic_strategy_;
  cache_pool_dynamic_strategy_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy* driving_config::mutable_cache_pool_dynamic_strategy() {
  
  if (cache_pool_dynamic_strategy_ == NULL) {
    cache_pool_dynamic_strategy_ = new ::xpilot::sr2_0::proto::cache_pool_dynamic_strategy;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.driving_config.cache_pool_dynamic_strategy)
  return cache_pool_dynamic_strategy_;
}
inline void driving_config::set_allocated_cache_pool_dynamic_strategy(::xpilot::sr2_0::proto::cache_pool_dynamic_strategy* cache_pool_dynamic_strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cache_pool_dynamic_strategy_;
  }
  if (cache_pool_dynamic_strategy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cache_pool_dynamic_strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cache_pool_dynamic_strategy, submessage_arena);
    }
    
  } else {
    
  }
  cache_pool_dynamic_strategy_ = cache_pool_dynamic_strategy;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.driving_config.cache_pool_dynamic_strategy)
}

// .xpilot.sr2_0.proto.lane_line_omit_frame_strategy lane_line_omit_frame_strategy = 26;
inline bool driving_config::has_lane_line_omit_frame_strategy() const {
  return this != internal_default_instance() && lane_line_omit_frame_strategy_ != NULL;
}
inline void driving_config::clear_lane_line_omit_frame_strategy() {
  if (GetArenaNoVirtual() == NULL && lane_line_omit_frame_strategy_ != NULL) {
    delete lane_line_omit_frame_strategy_;
  }
  lane_line_omit_frame_strategy_ = NULL;
}
inline const ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy& driving_config::lane_line_omit_frame_strategy() const {
  const ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy* p = lane_line_omit_frame_strategy_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.lane_line_omit_frame_strategy)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy*>(
      &::xpilot::sr2_0::proto::_lane_line_omit_frame_strategy_default_instance_);
}
inline ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy* driving_config::release_lane_line_omit_frame_strategy() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.driving_config.lane_line_omit_frame_strategy)
  
  ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy* temp = lane_line_omit_frame_strategy_;
  lane_line_omit_frame_strategy_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy* driving_config::mutable_lane_line_omit_frame_strategy() {
  
  if (lane_line_omit_frame_strategy_ == NULL) {
    lane_line_omit_frame_strategy_ = new ::xpilot::sr2_0::proto::lane_line_omit_frame_strategy;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.driving_config.lane_line_omit_frame_strategy)
  return lane_line_omit_frame_strategy_;
}
inline void driving_config::set_allocated_lane_line_omit_frame_strategy(::xpilot::sr2_0::proto::lane_line_omit_frame_strategy* lane_line_omit_frame_strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete lane_line_omit_frame_strategy_;
  }
  if (lane_line_omit_frame_strategy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      lane_line_omit_frame_strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, lane_line_omit_frame_strategy, submessage_arena);
    }
    
  } else {
    
  }
  lane_line_omit_frame_strategy_ = lane_line_omit_frame_strategy;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.driving_config.lane_line_omit_frame_strategy)
}

// .xpilot.sr2_0.proto.signal_light_status_strategy signal_light_status_strategy = 27;
inline bool driving_config::has_signal_light_status_strategy() const {
  return this != internal_default_instance() && signal_light_status_strategy_ != NULL;
}
inline void driving_config::clear_signal_light_status_strategy() {
  if (GetArenaNoVirtual() == NULL && signal_light_status_strategy_ != NULL) {
    delete signal_light_status_strategy_;
  }
  signal_light_status_strategy_ = NULL;
}
inline const ::xpilot::sr2_0::proto::signal_light_status_strategy& driving_config::signal_light_status_strategy() const {
  const ::xpilot::sr2_0::proto::signal_light_status_strategy* p = signal_light_status_strategy_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.signal_light_status_strategy)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::signal_light_status_strategy*>(
      &::xpilot::sr2_0::proto::_signal_light_status_strategy_default_instance_);
}
inline ::xpilot::sr2_0::proto::signal_light_status_strategy* driving_config::release_signal_light_status_strategy() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.driving_config.signal_light_status_strategy)
  
  ::xpilot::sr2_0::proto::signal_light_status_strategy* temp = signal_light_status_strategy_;
  signal_light_status_strategy_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::signal_light_status_strategy* driving_config::mutable_signal_light_status_strategy() {
  
  if (signal_light_status_strategy_ == NULL) {
    signal_light_status_strategy_ = new ::xpilot::sr2_0::proto::signal_light_status_strategy;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.driving_config.signal_light_status_strategy)
  return signal_light_status_strategy_;
}
inline void driving_config::set_allocated_signal_light_status_strategy(::xpilot::sr2_0::proto::signal_light_status_strategy* signal_light_status_strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete signal_light_status_strategy_;
  }
  if (signal_light_status_strategy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      signal_light_status_strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, signal_light_status_strategy, submessage_arena);
    }
    
  } else {
    
  }
  signal_light_status_strategy_ = signal_light_status_strategy;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.driving_config.signal_light_status_strategy)
}

// .xpilot.sr2_0.proto.intersection_recognition_strategy intersection_recognition_strategy = 28;
inline bool driving_config::has_intersection_recognition_strategy() const {
  return this != internal_default_instance() && intersection_recognition_strategy_ != NULL;
}
inline void driving_config::clear_intersection_recognition_strategy() {
  if (GetArenaNoVirtual() == NULL && intersection_recognition_strategy_ != NULL) {
    delete intersection_recognition_strategy_;
  }
  intersection_recognition_strategy_ = NULL;
}
inline const ::xpilot::sr2_0::proto::intersection_recognition_strategy& driving_config::intersection_recognition_strategy() const {
  const ::xpilot::sr2_0::proto::intersection_recognition_strategy* p = intersection_recognition_strategy_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.intersection_recognition_strategy)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::intersection_recognition_strategy*>(
      &::xpilot::sr2_0::proto::_intersection_recognition_strategy_default_instance_);
}
inline ::xpilot::sr2_0::proto::intersection_recognition_strategy* driving_config::release_intersection_recognition_strategy() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.driving_config.intersection_recognition_strategy)
  
  ::xpilot::sr2_0::proto::intersection_recognition_strategy* temp = intersection_recognition_strategy_;
  intersection_recognition_strategy_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::intersection_recognition_strategy* driving_config::mutable_intersection_recognition_strategy() {
  
  if (intersection_recognition_strategy_ == NULL) {
    intersection_recognition_strategy_ = new ::xpilot::sr2_0::proto::intersection_recognition_strategy;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.driving_config.intersection_recognition_strategy)
  return intersection_recognition_strategy_;
}
inline void driving_config::set_allocated_intersection_recognition_strategy(::xpilot::sr2_0::proto::intersection_recognition_strategy* intersection_recognition_strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete intersection_recognition_strategy_;
  }
  if (intersection_recognition_strategy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      intersection_recognition_strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intersection_recognition_strategy, submessage_arena);
    }
    
  } else {
    
  }
  intersection_recognition_strategy_ = intersection_recognition_strategy;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.driving_config.intersection_recognition_strategy)
}

// .xpilot.sr2_0.proto.tfl_blink_suppress_strategy tfl_blink_suppress_strategy = 29;
inline bool driving_config::has_tfl_blink_suppress_strategy() const {
  return this != internal_default_instance() && tfl_blink_suppress_strategy_ != NULL;
}
inline void driving_config::clear_tfl_blink_suppress_strategy() {
  if (GetArenaNoVirtual() == NULL && tfl_blink_suppress_strategy_ != NULL) {
    delete tfl_blink_suppress_strategy_;
  }
  tfl_blink_suppress_strategy_ = NULL;
}
inline const ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy& driving_config::tfl_blink_suppress_strategy() const {
  const ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy* p = tfl_blink_suppress_strategy_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.driving_config.tfl_blink_suppress_strategy)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy*>(
      &::xpilot::sr2_0::proto::_tfl_blink_suppress_strategy_default_instance_);
}
inline ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy* driving_config::release_tfl_blink_suppress_strategy() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.driving_config.tfl_blink_suppress_strategy)
  
  ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy* temp = tfl_blink_suppress_strategy_;
  tfl_blink_suppress_strategy_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy* driving_config::mutable_tfl_blink_suppress_strategy() {
  
  if (tfl_blink_suppress_strategy_ == NULL) {
    tfl_blink_suppress_strategy_ = new ::xpilot::sr2_0::proto::tfl_blink_suppress_strategy;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.driving_config.tfl_blink_suppress_strategy)
  return tfl_blink_suppress_strategy_;
}
inline void driving_config::set_allocated_tfl_blink_suppress_strategy(::xpilot::sr2_0::proto::tfl_blink_suppress_strategy* tfl_blink_suppress_strategy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tfl_blink_suppress_strategy_;
  }
  if (tfl_blink_suppress_strategy) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tfl_blink_suppress_strategy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tfl_blink_suppress_strategy, submessage_arena);
    }
    
  } else {
    
  }
  tfl_blink_suppress_strategy_ = tfl_blink_suppress_strategy;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.driving_config.tfl_blink_suppress_strategy)
}

// -------------------------------------------------------------------

// parking_config

// -------------------------------------------------------------------

// tfl_blink_suppress_strategy

// bool enable = 1;
inline void tfl_blink_suppress_strategy::clear_enable() {
  enable_ = false;
}
inline bool tfl_blink_suppress_strategy::enable() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.tfl_blink_suppress_strategy.enable)
  return enable_;
}
inline void tfl_blink_suppress_strategy::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.tfl_blink_suppress_strategy.enable)
}

// uint32 frame_count = 2;
inline void tfl_blink_suppress_strategy::clear_frame_count() {
  frame_count_ = 0u;
}
inline ::google::protobuf::uint32 tfl_blink_suppress_strategy::frame_count() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.tfl_blink_suppress_strategy.frame_count)
  return frame_count_;
}
inline void tfl_blink_suppress_strategy::set_frame_count(::google::protobuf::uint32 value) {
  
  frame_count_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.tfl_blink_suppress_strategy.frame_count)
}

// -------------------------------------------------------------------

// intersection_recognition_strategy

// bool enable = 1;
inline void intersection_recognition_strategy::clear_enable() {
  enable_ = false;
}
inline bool intersection_recognition_strategy::enable() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.intersection_recognition_strategy.enable)
  return enable_;
}
inline void intersection_recognition_strategy::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.intersection_recognition_strategy.enable)
}

// bool debug_log = 2;
inline void intersection_recognition_strategy::clear_debug_log() {
  debug_log_ = false;
}
inline bool intersection_recognition_strategy::debug_log() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.intersection_recognition_strategy.debug_log)
  return debug_log_;
}
inline void intersection_recognition_strategy::set_debug_log(bool value) {
  
  debug_log_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.intersection_recognition_strategy.debug_log)
}

// float speed_limit = 3;
inline void intersection_recognition_strategy::clear_speed_limit() {
  speed_limit_ = 0;
}
inline float intersection_recognition_strategy::speed_limit() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.intersection_recognition_strategy.speed_limit)
  return speed_limit_;
}
inline void intersection_recognition_strategy::set_speed_limit(float value) {
  
  speed_limit_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.intersection_recognition_strategy.speed_limit)
}

// .xpilot.sr2_0.proto.drive_into_condition drive_into_condition = 4;
inline bool intersection_recognition_strategy::has_drive_into_condition() const {
  return this != internal_default_instance() && drive_into_condition_ != NULL;
}
inline void intersection_recognition_strategy::clear_drive_into_condition() {
  if (GetArenaNoVirtual() == NULL && drive_into_condition_ != NULL) {
    delete drive_into_condition_;
  }
  drive_into_condition_ = NULL;
}
inline const ::xpilot::sr2_0::proto::drive_into_condition& intersection_recognition_strategy::drive_into_condition() const {
  const ::xpilot::sr2_0::proto::drive_into_condition* p = drive_into_condition_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.intersection_recognition_strategy.drive_into_condition)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::drive_into_condition*>(
      &::xpilot::sr2_0::proto::_drive_into_condition_default_instance_);
}
inline ::xpilot::sr2_0::proto::drive_into_condition* intersection_recognition_strategy::release_drive_into_condition() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.intersection_recognition_strategy.drive_into_condition)
  
  ::xpilot::sr2_0::proto::drive_into_condition* temp = drive_into_condition_;
  drive_into_condition_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::drive_into_condition* intersection_recognition_strategy::mutable_drive_into_condition() {
  
  if (drive_into_condition_ == NULL) {
    drive_into_condition_ = new ::xpilot::sr2_0::proto::drive_into_condition;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.intersection_recognition_strategy.drive_into_condition)
  return drive_into_condition_;
}
inline void intersection_recognition_strategy::set_allocated_drive_into_condition(::xpilot::sr2_0::proto::drive_into_condition* drive_into_condition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete drive_into_condition_;
  }
  if (drive_into_condition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      drive_into_condition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, drive_into_condition, submessage_arena);
    }
    
  } else {
    
  }
  drive_into_condition_ = drive_into_condition;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.intersection_recognition_strategy.drive_into_condition)
}

// .xpilot.sr2_0.proto.drive_out_condition drive_out_condition = 5;
inline bool intersection_recognition_strategy::has_drive_out_condition() const {
  return this != internal_default_instance() && drive_out_condition_ != NULL;
}
inline void intersection_recognition_strategy::clear_drive_out_condition() {
  if (GetArenaNoVirtual() == NULL && drive_out_condition_ != NULL) {
    delete drive_out_condition_;
  }
  drive_out_condition_ = NULL;
}
inline const ::xpilot::sr2_0::proto::drive_out_condition& intersection_recognition_strategy::drive_out_condition() const {
  const ::xpilot::sr2_0::proto::drive_out_condition* p = drive_out_condition_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.intersection_recognition_strategy.drive_out_condition)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::drive_out_condition*>(
      &::xpilot::sr2_0::proto::_drive_out_condition_default_instance_);
}
inline ::xpilot::sr2_0::proto::drive_out_condition* intersection_recognition_strategy::release_drive_out_condition() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.intersection_recognition_strategy.drive_out_condition)
  
  ::xpilot::sr2_0::proto::drive_out_condition* temp = drive_out_condition_;
  drive_out_condition_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::drive_out_condition* intersection_recognition_strategy::mutable_drive_out_condition() {
  
  if (drive_out_condition_ == NULL) {
    drive_out_condition_ = new ::xpilot::sr2_0::proto::drive_out_condition;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.intersection_recognition_strategy.drive_out_condition)
  return drive_out_condition_;
}
inline void intersection_recognition_strategy::set_allocated_drive_out_condition(::xpilot::sr2_0::proto::drive_out_condition* drive_out_condition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete drive_out_condition_;
  }
  if (drive_out_condition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      drive_out_condition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, drive_out_condition, submessage_arena);
    }
    
  } else {
    
  }
  drive_out_condition_ = drive_out_condition;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.intersection_recognition_strategy.drive_out_condition)
}

// -------------------------------------------------------------------

// drive_into_condition

// float dist_road_mark = 1;
inline void drive_into_condition::clear_dist_road_mark() {
  dist_road_mark_ = 0;
}
inline float drive_into_condition::dist_road_mark() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.drive_into_condition.dist_road_mark)
  return dist_road_mark_;
}
inline void drive_into_condition::set_dist_road_mark(float value) {
  
  dist_road_mark_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.drive_into_condition.dist_road_mark)
}

// float length_road_mark = 2;
inline void drive_into_condition::clear_length_road_mark() {
  length_road_mark_ = 0;
}
inline float drive_into_condition::length_road_mark() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.drive_into_condition.length_road_mark)
  return length_road_mark_;
}
inline void drive_into_condition::set_length_road_mark(float value) {
  
  length_road_mark_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.drive_into_condition.length_road_mark)
}

// float width_lane = 3;
inline void drive_into_condition::clear_width_lane() {
  width_lane_ = 0;
}
inline float drive_into_condition::width_lane() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.drive_into_condition.width_lane)
  return width_lane_;
}
inline void drive_into_condition::set_width_lane(float value) {
  
  width_lane_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.drive_into_condition.width_lane)
}

// uint32 length_search_laneline = 4;
inline void drive_into_condition::clear_length_search_laneline() {
  length_search_laneline_ = 0u;
}
inline ::google::protobuf::uint32 drive_into_condition::length_search_laneline() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.drive_into_condition.length_search_laneline)
  return length_search_laneline_;
}
inline void drive_into_condition::set_length_search_laneline(::google::protobuf::uint32 value) {
  
  length_search_laneline_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.drive_into_condition.length_search_laneline)
}

// -------------------------------------------------------------------

// drive_out_condition

// uint32 dist_ego_drive = 1;
inline void drive_out_condition::clear_dist_ego_drive() {
  dist_ego_drive_ = 0u;
}
inline ::google::protobuf::uint32 drive_out_condition::dist_ego_drive() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.drive_out_condition.dist_ego_drive)
  return dist_ego_drive_;
}
inline void drive_out_condition::set_dist_ego_drive(::google::protobuf::uint32 value) {
  
  dist_ego_drive_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.drive_out_condition.dist_ego_drive)
}

// -------------------------------------------------------------------

// signal_light_status_strategy

// bool open = 1;
inline void signal_light_status_strategy::clear_open() {
  open_ = false;
}
inline bool signal_light_status_strategy::open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.signal_light_status_strategy.open)
  return open_;
}
inline void signal_light_status_strategy::set_open(bool value) {
  
  open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.signal_light_status_strategy.open)
}

// bool yaw_dirction_debug = 2;
inline void signal_light_status_strategy::clear_yaw_dirction_debug() {
  yaw_dirction_debug_ = false;
}
inline bool signal_light_status_strategy::yaw_dirction_debug() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.signal_light_status_strategy.yaw_dirction_debug)
  return yaw_dirction_debug_;
}
inline void signal_light_status_strategy::set_yaw_dirction_debug(bool value) {
  
  yaw_dirction_debug_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.signal_light_status_strategy.yaw_dirction_debug)
}

// float yaw_dirction_left = 3;
inline void signal_light_status_strategy::clear_yaw_dirction_left() {
  yaw_dirction_left_ = 0;
}
inline float signal_light_status_strategy::yaw_dirction_left() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.signal_light_status_strategy.yaw_dirction_left)
  return yaw_dirction_left_;
}
inline void signal_light_status_strategy::set_yaw_dirction_left(float value) {
  
  yaw_dirction_left_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.signal_light_status_strategy.yaw_dirction_left)
}

// float yaw_dirction_right = 4;
inline void signal_light_status_strategy::clear_yaw_dirction_right() {
  yaw_dirction_right_ = 0;
}
inline float signal_light_status_strategy::yaw_dirction_right() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.signal_light_status_strategy.yaw_dirction_right)
  return yaw_dirction_right_;
}
inline void signal_light_status_strategy::set_yaw_dirction_right(float value) {
  
  yaw_dirction_right_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.signal_light_status_strategy.yaw_dirction_right)
}

// -------------------------------------------------------------------

// cache_pool_dynamic_strategy

// bool open = 1;
inline void cache_pool_dynamic_strategy::clear_open() {
  open_ = false;
}
inline bool cache_pool_dynamic_strategy::open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.open)
  return open_;
}
inline void cache_pool_dynamic_strategy::set_open(bool value) {
  
  open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.open)
}

// bool yaw_dirction_debug = 2;
inline void cache_pool_dynamic_strategy::clear_yaw_dirction_debug() {
  yaw_dirction_debug_ = false;
}
inline bool cache_pool_dynamic_strategy::yaw_dirction_debug() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.yaw_dirction_debug)
  return yaw_dirction_debug_;
}
inline void cache_pool_dynamic_strategy::set_yaw_dirction_debug(bool value) {
  
  yaw_dirction_debug_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.yaw_dirction_debug)
}

// float yaw_dirction_left = 3;
inline void cache_pool_dynamic_strategy::clear_yaw_dirction_left() {
  yaw_dirction_left_ = 0;
}
inline float cache_pool_dynamic_strategy::yaw_dirction_left() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.yaw_dirction_left)
  return yaw_dirction_left_;
}
inline void cache_pool_dynamic_strategy::set_yaw_dirction_left(float value) {
  
  yaw_dirction_left_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.yaw_dirction_left)
}

// float yaw_dirction_right = 4;
inline void cache_pool_dynamic_strategy::clear_yaw_dirction_right() {
  yaw_dirction_right_ = 0;
}
inline float cache_pool_dynamic_strategy::yaw_dirction_right() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.yaw_dirction_right)
  return yaw_dirction_right_;
}
inline void cache_pool_dynamic_strategy::set_yaw_dirction_right(float value) {
  
  yaw_dirction_right_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.yaw_dirction_right)
}

// uint32 run_cache_count = 5;
inline void cache_pool_dynamic_strategy::clear_run_cache_count() {
  run_cache_count_ = 0u;
}
inline ::google::protobuf::uint32 cache_pool_dynamic_strategy::run_cache_count() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.run_cache_count)
  return run_cache_count_;
}
inline void cache_pool_dynamic_strategy::set_run_cache_count(::google::protobuf::uint32 value) {
  
  run_cache_count_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.run_cache_count)
}

// uint32 stop_cache_count = 6;
inline void cache_pool_dynamic_strategy::clear_stop_cache_count() {
  stop_cache_count_ = 0u;
}
inline ::google::protobuf::uint32 cache_pool_dynamic_strategy::stop_cache_count() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.stop_cache_count)
  return stop_cache_count_;
}
inline void cache_pool_dynamic_strategy::set_stop_cache_count(::google::protobuf::uint32 value) {
  
  stop_cache_count_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.stop_cache_count)
}

// float self_vehicle_stop_speed = 7;
inline void cache_pool_dynamic_strategy::clear_self_vehicle_stop_speed() {
  self_vehicle_stop_speed_ = 0;
}
inline float cache_pool_dynamic_strategy::self_vehicle_stop_speed() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.self_vehicle_stop_speed)
  return self_vehicle_stop_speed_;
}
inline void cache_pool_dynamic_strategy::set_self_vehicle_stop_speed(float value) {
  
  self_vehicle_stop_speed_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.self_vehicle_stop_speed)
}

// float union_rate_min = 8;
inline void cache_pool_dynamic_strategy::clear_union_rate_min() {
  union_rate_min_ = 0;
}
inline float cache_pool_dynamic_strategy::union_rate_min() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.union_rate_min)
  return union_rate_min_;
}
inline void cache_pool_dynamic_strategy::set_union_rate_min(float value) {
  
  union_rate_min_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.union_rate_min)
}

// float update_max_velocity = 9;
inline void cache_pool_dynamic_strategy::clear_update_max_velocity() {
  update_max_velocity_ = 0;
}
inline float cache_pool_dynamic_strategy::update_max_velocity() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.update_max_velocity)
  return update_max_velocity_;
}
inline void cache_pool_dynamic_strategy::set_update_max_velocity(float value) {
  
  update_max_velocity_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.update_max_velocity)
}

// float update_max_distance = 10;
inline void cache_pool_dynamic_strategy::clear_update_max_distance() {
  update_max_distance_ = 0;
}
inline float cache_pool_dynamic_strategy::update_max_distance() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.update_max_distance)
  return update_max_distance_;
}
inline void cache_pool_dynamic_strategy::set_update_max_distance(float value) {
  
  update_max_distance_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.update_max_distance)
}

// float check_delta_dist = 11;
inline void cache_pool_dynamic_strategy::clear_check_delta_dist() {
  check_delta_dist_ = 0;
}
inline float cache_pool_dynamic_strategy::check_delta_dist() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.check_delta_dist)
  return check_delta_dist_;
}
inline void cache_pool_dynamic_strategy::set_check_delta_dist(float value) {
  
  check_delta_dist_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.check_delta_dist)
}

// float check_delta_time = 12;
inline void cache_pool_dynamic_strategy::clear_check_delta_time() {
  check_delta_time_ = 0;
}
inline float cache_pool_dynamic_strategy::check_delta_time() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.check_delta_time)
  return check_delta_time_;
}
inline void cache_pool_dynamic_strategy::set_check_delta_time(float value) {
  
  check_delta_time_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_dynamic_strategy.check_delta_time)
}

// -------------------------------------------------------------------

// cache_pool_static_strategy

// bool open = 1;
inline void cache_pool_static_strategy::clear_open() {
  open_ = false;
}
inline bool cache_pool_static_strategy::open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_static_strategy.open)
  return open_;
}
inline void cache_pool_static_strategy::set_open(bool value) {
  
  open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_static_strategy.open)
}

// bool open_sod = 2;
inline void cache_pool_static_strategy::clear_open_sod() {
  open_sod_ = false;
}
inline bool cache_pool_static_strategy::open_sod() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_static_strategy.open_sod)
  return open_sod_;
}
inline void cache_pool_static_strategy::set_open_sod(bool value) {
  
  open_sod_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_static_strategy.open_sod)
}

// uint32 cache_count = 3;
inline void cache_pool_static_strategy::clear_cache_count() {
  cache_count_ = 0u;
}
inline ::google::protobuf::uint32 cache_pool_static_strategy::cache_count() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_static_strategy.cache_count)
  return cache_count_;
}
inline void cache_pool_static_strategy::set_cache_count(::google::protobuf::uint32 value) {
  
  cache_count_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_static_strategy.cache_count)
}

// float min_dist = 4;
inline void cache_pool_static_strategy::clear_min_dist() {
  min_dist_ = 0;
}
inline float cache_pool_static_strategy::min_dist() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_static_strategy.min_dist)
  return min_dist_;
}
inline void cache_pool_static_strategy::set_min_dist(float value) {
  
  min_dist_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_static_strategy.min_dist)
}

// float check_delta_dist = 5;
inline void cache_pool_static_strategy::clear_check_delta_dist() {
  check_delta_dist_ = 0;
}
inline float cache_pool_static_strategy::check_delta_dist() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_static_strategy.check_delta_dist)
  return check_delta_dist_;
}
inline void cache_pool_static_strategy::set_check_delta_dist(float value) {
  
  check_delta_dist_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_static_strategy.check_delta_dist)
}

// float check_delta_time = 6;
inline void cache_pool_static_strategy::clear_check_delta_time() {
  check_delta_time_ = 0;
}
inline float cache_pool_static_strategy::check_delta_time() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.cache_pool_static_strategy.check_delta_time)
  return check_delta_time_;
}
inline void cache_pool_static_strategy::set_check_delta_time(float value) {
  
  check_delta_time_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.cache_pool_static_strategy.check_delta_time)
}

// -------------------------------------------------------------------

// dynamic_pose_filter_strategy

// bool open = 1;
inline void dynamic_pose_filter_strategy::clear_open() {
  open_ = false;
}
inline bool dynamic_pose_filter_strategy::open() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.dynamic_pose_filter_strategy.open)
  return open_;
}
inline void dynamic_pose_filter_strategy::set_open(bool value) {
  
  open_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.dynamic_pose_filter_strategy.open)
}

// uint32 cache_count = 2;
inline void dynamic_pose_filter_strategy::clear_cache_count() {
  cache_count_ = 0u;
}
inline ::google::protobuf::uint32 dynamic_pose_filter_strategy::cache_count() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.dynamic_pose_filter_strategy.cache_count)
  return cache_count_;
}
inline void dynamic_pose_filter_strategy::set_cache_count(::google::protobuf::uint32 value) {
  
  cache_count_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.dynamic_pose_filter_strategy.cache_count)
}

// float vehicle_stop_speed = 3;
inline void dynamic_pose_filter_strategy::clear_vehicle_stop_speed() {
  vehicle_stop_speed_ = 0;
}
inline float dynamic_pose_filter_strategy::vehicle_stop_speed() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.dynamic_pose_filter_strategy.vehicle_stop_speed)
  return vehicle_stop_speed_;
}
inline void dynamic_pose_filter_strategy::set_vehicle_stop_speed(float value) {
  
  vehicle_stop_speed_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.dynamic_pose_filter_strategy.vehicle_stop_speed)
}

// -------------------------------------------------------------------

// lane_line_omit_frame_strategy

// bool enable = 1;
inline void lane_line_omit_frame_strategy::clear_enable() {
  enable_ = false;
}
inline bool lane_line_omit_frame_strategy::enable() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.enable)
  return enable_;
}
inline void lane_line_omit_frame_strategy::set_enable(bool value) {
  
  enable_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.enable)
}

// .xpilot.sr2_0.proto.low_speed_case low_speed_case = 2;
inline bool lane_line_omit_frame_strategy::has_low_speed_case() const {
  return this != internal_default_instance() && low_speed_case_ != NULL;
}
inline void lane_line_omit_frame_strategy::clear_low_speed_case() {
  if (GetArenaNoVirtual() == NULL && low_speed_case_ != NULL) {
    delete low_speed_case_;
  }
  low_speed_case_ = NULL;
}
inline const ::xpilot::sr2_0::proto::low_speed_case& lane_line_omit_frame_strategy::low_speed_case() const {
  const ::xpilot::sr2_0::proto::low_speed_case* p = low_speed_case_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.low_speed_case)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::low_speed_case*>(
      &::xpilot::sr2_0::proto::_low_speed_case_default_instance_);
}
inline ::xpilot::sr2_0::proto::low_speed_case* lane_line_omit_frame_strategy::release_low_speed_case() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.low_speed_case)
  
  ::xpilot::sr2_0::proto::low_speed_case* temp = low_speed_case_;
  low_speed_case_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::low_speed_case* lane_line_omit_frame_strategy::mutable_low_speed_case() {
  
  if (low_speed_case_ == NULL) {
    low_speed_case_ = new ::xpilot::sr2_0::proto::low_speed_case;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.low_speed_case)
  return low_speed_case_;
}
inline void lane_line_omit_frame_strategy::set_allocated_low_speed_case(::xpilot::sr2_0::proto::low_speed_case* low_speed_case) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete low_speed_case_;
  }
  if (low_speed_case) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      low_speed_case = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, low_speed_case, submessage_arena);
    }
    
  } else {
    
  }
  low_speed_case_ = low_speed_case;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.low_speed_case)
}

// .xpilot.sr2_0.proto.static_case static_case = 3;
inline bool lane_line_omit_frame_strategy::has_static_case() const {
  return this != internal_default_instance() && static_case_ != NULL;
}
inline void lane_line_omit_frame_strategy::clear_static_case() {
  if (GetArenaNoVirtual() == NULL && static_case_ != NULL) {
    delete static_case_;
  }
  static_case_ = NULL;
}
inline const ::xpilot::sr2_0::proto::static_case& lane_line_omit_frame_strategy::static_case() const {
  const ::xpilot::sr2_0::proto::static_case* p = static_case_;
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.static_case)
  return p != NULL ? *p : *reinterpret_cast<const ::xpilot::sr2_0::proto::static_case*>(
      &::xpilot::sr2_0::proto::_static_case_default_instance_);
}
inline ::xpilot::sr2_0::proto::static_case* lane_line_omit_frame_strategy::release_static_case() {
  // @@protoc_insertion_point(field_release:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.static_case)
  
  ::xpilot::sr2_0::proto::static_case* temp = static_case_;
  static_case_ = NULL;
  return temp;
}
inline ::xpilot::sr2_0::proto::static_case* lane_line_omit_frame_strategy::mutable_static_case() {
  
  if (static_case_ == NULL) {
    static_case_ = new ::xpilot::sr2_0::proto::static_case;
  }
  // @@protoc_insertion_point(field_mutable:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.static_case)
  return static_case_;
}
inline void lane_line_omit_frame_strategy::set_allocated_static_case(::xpilot::sr2_0::proto::static_case* static_case) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete static_case_;
  }
  if (static_case) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      static_case = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, static_case, submessage_arena);
    }
    
  } else {
    
  }
  static_case_ = static_case;
  // @@protoc_insertion_point(field_set_allocated:xpilot.sr2_0.proto.lane_line_omit_frame_strategy.static_case)
}

// -------------------------------------------------------------------

// low_speed_case

// uint32 frame_count = 1;
inline void low_speed_case::clear_frame_count() {
  frame_count_ = 0u;
}
inline ::google::protobuf::uint32 low_speed_case::frame_count() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.low_speed_case.frame_count)
  return frame_count_;
}
inline void low_speed_case::set_frame_count(::google::protobuf::uint32 value) {
  
  frame_count_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.low_speed_case.frame_count)
}

// float speed_ceiling = 2;
inline void low_speed_case::clear_speed_ceiling() {
  speed_ceiling_ = 0;
}
inline float low_speed_case::speed_ceiling() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.low_speed_case.speed_ceiling)
  return speed_ceiling_;
}
inline void low_speed_case::set_speed_ceiling(float value) {
  
  speed_ceiling_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.low_speed_case.speed_ceiling)
}

// -------------------------------------------------------------------

// static_case

// uint32 frame_count = 1;
inline void static_case::clear_frame_count() {
  frame_count_ = 0u;
}
inline ::google::protobuf::uint32 static_case::frame_count() const {
  // @@protoc_insertion_point(field_get:xpilot.sr2_0.proto.static_case.frame_count)
  return frame_count_;
}
inline void static_case::set_frame_count(::google::protobuf::uint32 value) {
  
  frame_count_ = value;
  // @@protoc_insertion_point(field_set:xpilot.sr2_0.proto.static_case.frame_count)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace sr2_0
}  // namespace xpilot

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_addressbook_2eproto__INCLUDED
